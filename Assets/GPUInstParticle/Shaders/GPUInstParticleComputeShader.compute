// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#pragma kernel CSInitial

#include "PerlinNoise.cginc"
#include "SphericalHammersley.cginc"
#include "GPUInstParticleData.cginc"


// particle
RWStructuredBuffer<particle> particleBuffer;

float3 _particlePosWorld;

float _DeltaTime;

int _ParticleCount;

float _NoiseScale;

float _SpeedFactor;

float _LiftTime;

float _ElapsedTime;

float Rand(float v)
{
	return (frac(sin(v * 12.9898) * 43758.5453) + 1) * 0.5;
}

float3 Pnoise(float3 vec)
{
	float x = PerlinNoise(vec);

	float y = PerlinNoise(float3(
		vec.y + 31.416,
		vec.z - 47.853,
		vec.x + 12.793
		));

	float z = PerlinNoise(float3(
		vec.z - 233.145,
		vec.x - 113.408,
		vec.y - 185.31
		));

	return float3(x, y, z);
}

float3 SamplePotential(float3 pos)
{
	float3 s = (pos  + _ElapsedTime.xxx) / _NoiseScale;
	return Pnoise(s);
}

float3 CurlNoise(float3 pos)
{
	const float e = 0.0009765625;
	const float e2 = 2.0 * e;
	const float invE2 = 1.0 / e2;

	const float3 dx = float3(e, 0.0, 0.0);
	const float3 dy = float3(0.0, e, 0.0);
	const float3 dz = float3(0.0, 0.0, e);

	float3 p_x0 = SamplePotential(pos - dx);
	float3 p_x1 = SamplePotential(pos + dx);
	float3 p_y0 = SamplePotential(pos - dy);
	float3 p_y1 = SamplePotential(pos + dy);
	float3 p_z0 = SamplePotential(pos - dz);
	float3 p_z1 = SamplePotential(pos + dz);

	float x = (p_y1.z - p_y0.z) - (p_z1.y - p_z0.y);
	float y = (p_z1.x - p_z0.x) - (p_x1.z - p_x0.z);
	float z = (p_x1.y - p_x0.y) - (p_y1.x - p_y0.x);

	return float3(x, y, z) * invE2;
}

void initParticle(uint idx, uint rand)
{
	float3 pos = SphericalHammersley((idx + rand)*4, _ParticleCount);

	float radius = Rand(idx + rand);

	particleBuffer[idx].position = pos * radius + _particlePosWorld;

	particleBuffer[idx].color = (pos.xzy + 1.0) * 0.5;

	particleBuffer[idx].velocity = pos;

	particleBuffer[idx].lifeTime = 0;

	particleBuffer[idx].scale = 0;
}


[numthreads(64,1,1)]
void CSMain (uint id : SV_DispatchThreadID)
{
	if (_ParticleCount <= (int)id) return;

	if (0 < particleBuffer[id].delayTime) {
		particleBuffer[id].delayTime -= _DeltaTime;
		particleBuffer[id].scale = 0;
		return;
	}

	float3 pos = particleBuffer[id].position;

	float3 velocity = CurlNoise(pos);
	// restrict direction move forward x - axis
	velocity.x += 1;

	particleBuffer[id].velocity = velocity * _SpeedFactor;

	particleBuffer[id].color = (velocity.xzy + 1.0) * 0.5;

	particleBuffer[id].position = pos + particleBuffer[id].velocity * _DeltaTime;

	particleBuffer[id].lifeTime += _DeltaTime;

	particleBuffer[id].scale = 1 - (particleBuffer[id].lifeTime / _LiftTime);

	if (particleBuffer[id].scale < 0)
	{
		initParticle(id, (uint)_ElapsedTime);
	}
}

[numthreads(64, 1, 1)]
void CSInitial(uint id : SV_DispatchThreadID)
{
	if (_ParticleCount <= (int)id) return;

	initParticle(id, 0);

	particleBuffer[id].delayTime = ((float)id / _ParticleCount) * _LiftTime;
}
