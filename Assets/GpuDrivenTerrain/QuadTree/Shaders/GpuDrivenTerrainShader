Shader "GpuDriven/GpuDrivenTerrainShader"
{
    Properties
    {
    }
    SubShader
    {
        Tags { "RenderType" = "Opaque" "RenderPipeline" = "UniversalPipeline" }
        LOD 100

        Pass
        {
            Name "Normal"

            HLSLPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            #pragma target 4.5  // for compute shader support

            #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"

            #include "RenderPatch.cginc"

            float offsetLOD;

            #if SHADER_TARGET >= 45
            StructuredBuffer<RenderPatch> CulledPatchList;
            #endif

            struct appdata
            {
                float4 vertex : POSITION;
                half4 color : COLOR;
                uint uv : TEXCOORD0;
            };

            struct v2f
            {
                float4 vertex : SV_POSITION;
            };

            v2f vert (appdata v, uint instanceID : SV_InstanceID)
            {
                v2f o;

#if SHADER_TARGET >= 45
                RenderPatch data = CulledPatchList[instanceID];
#else
                RenderPatch data = 0;
#endif
                uint row = (v.uv & 0xffff) + (data.coordinate & 0xffff);
                uint col = ((v.uv >> 16) & 0xffff) + ((data.coordinate >> 16) & 0xffff);

                uint2 coordinate = uint2(row, col);
                uint4 neighbor = uint4(data.neighbor, (data.neighbor >> 8), (data.neighbor >> 16), (data.neighbor >> 24)) & 0xff;
                neighbor = uint4(1 << neighbor.r, 1 << neighbor.g, 1 << neighbor.b, 1 << neighbor.a);
                neighbor = neighbor.rgba - 1;

                float2 offset = float2(0, 0);
                offset -= v.color.rg * (coordinate & neighbor.rg);
                offset -= v.color.ab * (coordinate & neighbor.ab);

                float3 position = v.vertex.xyz;
                position.xz += offset * offsetLOD;
                position.xz *= (1 << data.lod);
                position.xz += data.position;

                o.vertex = mul(unity_MatrixVP, float4(position, 1));
                return o;
            }

            half3 frag (v2f i) : SV_Target
            {
                return 1;
            }
            ENDHLSL
        }

        Pass
        {
            Name "Wireframe"

            Cull Off
            ZTest Always

            HLSLPROGRAM
            #pragma vertex vert
            #pragma geometry geom
            #pragma fragment frag

            #pragma target 4.5  // for compute shader support
            #pragma require compute
            #pragma require instancing
            #pragma require geometry

            #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"

            #include "RenderPatch.cginc"

            float offsetLOD;

            #if SHADER_TARGET >= 45
            StructuredBuffer<RenderPatch> CulledPatchList;
            #endif

            struct appdata
            {
                float4 vertex : POSITION;
                half4 color : COLOR;
                uint uv : TEXCOORD0;
            };

            struct v2g
            {
                float4 vertex : POSITION;
            };

            struct g2f
            {
                float4 vertex : SV_POSITION;
            };

            v2g vert(appdata v, uint instanceID : SV_InstanceID)
            {
                v2g o;

#if SHADER_TARGET >= 45
                RenderPatch data = CulledPatchList[instanceID];
#else
                RenderPatch data = 0;
#endif
                uint row = (v.uv & 0xffff) + (data.coordinate & 0xffff);
                uint col = ((v.uv >> 16) & 0xffff) + ((data.coordinate >> 16) & 0xffff);

                uint2 coordinate = uint2(row, col);
                uint4 neighbor = uint4(data.neighbor, (data.neighbor >> 8), (data.neighbor >> 16), (data.neighbor >> 24)) & 0xff;                
                neighbor = uint4(1 << neighbor.r, 1 << neighbor.g, 1 << neighbor.b, 1 << neighbor.a);
                neighbor = neighbor.rgba - 1;

                float2 offset = float2(0, 0);
                offset -= v.color.rg * (coordinate & neighbor.rg);
                offset -= v.color.ab * (coordinate & neighbor.ab);

                float3 position = v.vertex.xyz;
                position.xz += offset * offsetLOD;
                position.xz *= (1 << data.lod);
                position.xz += data.position;

                o.vertex = mul(unity_MatrixVP, float4(position, 1));
                return o;
            }

            [maxvertexcount(6)]
            void geom(triangle v2g input[3], inout LineStream<g2f> lineStream)
            {
                g2f o1, o2, o3;

                o1 = input[0];
                o2 = input[1];
                o3 = input[2];

                lineStream.Append(o1);
                lineStream.Append(o2);
                lineStream.RestartStrip();

                lineStream.Append(o2);
                lineStream.Append(o3);
                lineStream.RestartStrip();

                lineStream.Append(o3);
                lineStream.Append(o1);
                lineStream.RestartStrip();
            }

            half3 frag(g2f i) : SV_Target
            {
                return 0;
            }
            ENDHLSL
        }
    }
}
