#include "QuadTreeCore.cginc"
#include "RenderPatch.cginc"

#pragma kernel BuildPatches

StructuredBuffer<uint3> FinalNodeList;
AppendStructuredBuffer<RenderPatch> RenderPatchList;

Texture2D<float> LodMap;

uint NodeSizeAtMaxLOD;

uint LodMeshStep;

bool isUpSide(uint2 offset)
{
	return offset.y == (PATCH_COUNT_IN_NODE - 1);
}

bool isDownSide(uint2 offset)
{
	return offset.y == 0;
}

bool isRightSide(uint2 offset)
{
	return offset.x == (PATCH_COUNT_IN_NODE - 1);
}

bool isLeftSide(uint2 offset)
{
	return offset.x == 0;
}

int2 NodeAtLod0(uint3 node)
{
	return node.xy << (node.z);
}

float GetLodValue(int2 nodeAtLod0, int2 offset)
{
	uint nodeCount = (NodeSizeAtMaxLOD << MaxLOD);
	return LodMap.mips[0][clamp(nodeAtLod0 + offset,0, nodeCount - 1)];
}

[numthreads(PATCH_COUNT_IN_NODE, PATCH_COUNT_IN_NODE, 1)]
void BuildPatches(uint3 id : SV_DispatchThreadID, uint3 groupId : SV_GroupID, uint3 groupThreadID : SV_GroupThreadID)
{
	uint3 node = FinalNodeList[groupId.x];
	uint2 patchOffset = groupThreadID.xy;

	RenderPatch patch;
	patch.position = CalcPatchPos(node.xy, patchOffset, node.z);
	patch.lod = node.z;
	patch.neighbor = 0;
	patch.coordinate = (((patchOffset.y * LodMeshStep) & 0xffff) << 16) | ((patchOffset.x * LodMeshStep) & 0xffff);

	float valueLod = ((float)node.z) / MaxLOD;
	float neighborLod = 0;
	int2 nodeAtLod0 = NodeAtLod0(node);
	int diff = 1 << node.z;
		
	if (isUpSide(patchOffset) == true)
	{
		neighborLod = GetLodValue(nodeAtLod0, int2(0, diff));
		if (valueLod < neighborLod)
		{
			patch.neighbor |= (uint((neighborLod - valueLod) * MaxLOD) & 0xff);
		}
	}

	if (isRightSide(patchOffset) == true)
	{
		neighborLod = GetLodValue(nodeAtLod0, int2(diff, 0));
		if (valueLod < neighborLod)
		{
			patch.neighbor |= (uint((neighborLod - valueLod) * MaxLOD) & 0xff) << 8;
		}
	}

	if (isLeftSide(patchOffset) == true)
	{
		neighborLod = GetLodValue(nodeAtLod0, int2(-1, 0));
		if (valueLod < neighborLod)
		{
			patch.neighbor |= (uint((neighborLod - valueLod) * MaxLOD) & 0xff) << 16;
		}
	}
	
	if (isDownSide(patchOffset) == true)
	{
		neighborLod = GetLodValue(nodeAtLod0, int2(0, -1));
		if (valueLod < neighborLod)
		{
			patch.neighbor |= (uint((neighborLod - valueLod) * MaxLOD) & 0xff) << 24;
		}
	}

	RenderPatchList.Append(patch);
}
