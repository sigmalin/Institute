// Each #kernel tells which function to compile; you can have many kernels
#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"

#pragma kernel CSDownSample

float4 _RT_Size;

Texture2D _HiZTexture;
RWTexture2D<float> _mipDepthTexture;

SamplerState pointClampSampler;


[numthreads(8, 8, 1)]
void CSDownSample(uint3 id : SV_DispatchThreadID)
{
    if (_RT_Size.x <= (float)id.x || _RT_Size.y <= (float)id.y) return;

    float2 screenUV = id.xy * _RT_Size.zw;

    float4 depth;

    float2 uv0 = screenUV + float2(-0.25, -0.25) * _RT_Size.zw;
    float2 uv1 = screenUV + float2(-0.25,  0.25) * _RT_Size.zw;
    float2 uv2 = screenUV + float2( 0.25, -0.25) * _RT_Size.zw;
    float2 uv3 = screenUV + float2( 0.25,  0.25) * _RT_Size.zw;

    depth.x = _HiZTexture.SampleLevel(pointClampSampler, uv0, 0).r;
    depth.y = _HiZTexture.SampleLevel(pointClampSampler, uv1, 0).r;
    depth.z = _HiZTexture.SampleLevel(pointClampSampler, uv2, 0).r;
    depth.w = _HiZTexture.SampleLevel(pointClampSampler, uv3, 0).r;

#if defined(UNITY_REVERSED_Z)
    _mipDepthTexture[id.xy] = min(min(depth.x, depth.y), min(depth.z, depth.w));
#else
    _mipDepthTexture[id.xy] = max(max(depth.x, depth.y), max(depth.z, depth.w));
#endif
}
