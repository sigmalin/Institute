#include "RenderPatch.hlsl"

#pragma kernel CSCullingPatches

StructuredBuffer<RenderPatch> patchesBuffer;

float4x4 matrixVP;

int meshRadius;

int isOpenGL;

AppendStructuredBuffer<RenderPatch> cullingResult;

bool IsInClipSpace(float4 clipSpacePosition)
{
    bool result = false;
    if (max(abs(clipSpacePosition.x), abs(clipSpacePosition.y)) <= clipSpacePosition.w) {
        float nearClipZ = (isOpenGL == 1) ? -clipSpacePosition.w : 0.0;
        result = nearClipZ < clipSpacePosition.z&& clipSpacePosition.z < clipSpacePosition.w;
    }
    
    return result;
}

[numthreads(1, 1, 1)]
void CSCullingPatches(uint id : SV_DispatchThreadID)
{
    RenderPatch patch = patchesBuffer[id];

    float size = meshRadius << patch.lod;
    float minHeight = 0;
    float maxHeight = 10;

    float3 boundVerts[8];
    boundVerts[0] = float3(patch.position.x       , minHeight, patch.position.y);
    boundVerts[1] = float3(patch.position.x + size, maxHeight, patch.position.y + size);
    boundVerts[2] = float3(patch.position.x + size, maxHeight, patch.position.y);
    boundVerts[3] = float3(patch.position.x + size, minHeight, patch.position.y + size);
    boundVerts[4] = float3(patch.position.x + size, minHeight, patch.position.y);
    boundVerts[5] = float3(patch.position.x       , maxHeight, patch.position.y + size);
    boundVerts[6] = float3(patch.position.x       , maxHeight, patch.position.y);
    boundVerts[7] = float3(patch.position.x       , minHeight, patch.position.y + size);
    

    for (int i = 0; i < 8; ++i) {
        float4 worldSpace = float4(boundVerts[i], 1.0);
        float4 clipSpece = mul(matrixVP, worldSpace);

        if (IsInClipSpace(clipSpece) == true) {
            cullingResult.Append(patch);
            return;
        }
    }
}
