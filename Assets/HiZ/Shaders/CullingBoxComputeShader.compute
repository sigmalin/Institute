// https://zhuanlan.zhihu.com/p/396979267
// https://zhuanlan.zhihu.com/p/362713511
// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSCullingBox

StructuredBuffer<float3> postionBuffer;

int _ObjectCount;

float3 _boundMin;
float3 _boundMax;

float4x4 matrixVP;

bool _isOpenGL;

float2 _RT_Size;
uint _MaxMipLevel;

Texture2D _HiZTexture;

AppendStructuredBuffer<float3> cullingResult;

bool IsInClipSpace(float4 clipSpacePosition)
{
    if (clipSpacePosition.w < max(abs(clipSpacePosition.x), abs(clipSpacePosition.y))) {
        return false;
    }

    float nearClipZ = _isOpenGL ? -clipSpacePosition.w : 0.0;
    return nearClipZ < clipSpacePosition.z && clipSpacePosition.z < clipSpacePosition.w;
}

float GetFarestDepth(float depth1, float depth2)
{
    return _isOpenGL ? max(depth1, depth2) : min(depth1, depth2);
}

bool IsBehide(float srcDepth, float destDepth) 
{
    return _isOpenGL ? destDepth < srcDepth : srcDepth < destDepth;
}

[numthreads(64,1,1)]
void CSCullingBox(uint id : SV_DispatchThreadID)
{
    if (_ObjectCount <= (int)id) return;

    float3 centerPos = postionBuffer[id];

    float3 boundVerts[8];
    boundVerts[0] = _boundMin;
    boundVerts[1] = _boundMax;
    boundVerts[2] = float3(_boundMax.x, _boundMax.y, _boundMin.z);
    boundVerts[3] = float3(_boundMax.x, _boundMin.y, _boundMax.z);
    boundVerts[4] = float3(_boundMax.x, _boundMin.y, _boundMin.z);
    boundVerts[5] = float3(_boundMin.x, _boundMax.y, _boundMax.z);
    boundVerts[6] = float3(_boundMin.x, _boundMax.y, _boundMin.z);
    boundVerts[7] = float3(_boundMin.x, _boundMin.y, _boundMax.z);

    float minNdcX = 1, minNdcY = 1, minNdcZ = 1;
    float maxNdcX = -1, maxNdcY = -1, maxNdcZ = -1;

    bool isInSide = false;
    for (int i = 0; i < 8; ++i) {
        float4 worldSpace = float4(centerPos + boundVerts[i], 1.0);
        float4 clipSpece = mul(matrixVP, worldSpace);

        if (isInSide == false && IsInClipSpace(clipSpece) == true) {
            isInSide = true;
        }

        // calculate AABB in NDC
        float3 ndc = clipSpece.xyz / clipSpece.w;
        minNdcX = min(minNdcX, ndc.x);
        minNdcY = min(minNdcY, ndc.y);
        minNdcZ = min(minNdcZ, ndc.z);
        maxNdcX = max(maxNdcX, ndc.x);
        maxNdcY = max(maxNdcY, ndc.y);
        maxNdcZ = max(maxNdcZ, ndc.z);
    }

    if (isInSide == false) {
        // outside of frustum
        return;
    }

    float lenNdcX = (maxNdcX - minNdcX) * 0.5; // len of x-axis in ndc space = 2 
    float lenNdcY = (maxNdcY - minNdcY) * 0.5;
    float boundSize = max(lenNdcX * _RT_Size.x, lenNdcY * _RT_Size.y);

    uint mips = (uint)clamp(log2(boundSize * 0.5), 0, _MaxMipLevel);
    uint texScale = 1 << mips;

    float2 uv0 = float2(minNdcX, minNdcY) * 0.5 + float2(0.5, 0.5);
    float2 uv1 = float2(minNdcX, maxNdcY) * 0.5 + float2(0.5, 0.5);
    float2 uv2 = float2(maxNdcX, minNdcY) * 0.5 + float2(0.5, 0.5);
    float2 uv3 = float2(maxNdcX, maxNdcY) * 0.5 + float2(0.5, 0.5);
    
    uint2 pixel0 = uint2((uv0 * _RT_Size) / texScale);
    uint2 pixel1 = uint2((uv1 * _RT_Size) / texScale);
    uint2 pixel2 = uint2((uv2 * _RT_Size) / texScale);
    uint2 pixel3 = uint2((uv3 * _RT_Size) / texScale);
    
    float depthInTexture = GetFarestDepth(
        GetFarestDepth(_HiZTexture.mips[mips][pixel0].r, _HiZTexture.mips[mips][pixel1].r),
        GetFarestDepth(_HiZTexture.mips[mips][pixel2].r, _HiZTexture.mips[mips][pixel3].r)
        );
    
    if (IsBehide(depth, depthInTexture)) {
        return;
    }
    
    cullingResult.Append(postionBuffer[id]);
}
